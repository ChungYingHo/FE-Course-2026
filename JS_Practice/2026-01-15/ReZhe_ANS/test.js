/* eslint-disable no-undef */
/* ------------------------------------------------
題目 1：變數宣告與重新賦值
------------------------------------------------ */

let a = 10
a = a + 5

console.log(a)
// 問題：輸出結果是什麼？
// 答案：輸出答案為：15，算式： a = 10 + 5

/* ------------------------------------------------
題目 2：const 的行為
------------------------------------------------ */

const obj = { value: 1 }
obj.value = 2

console.log(obj.value)
// 問題：這段程式碼會不會報錯？為什麼？
// 答案：不會報錯，因為這邊只是對物件內容做改變而已，並不是重新覆值

/* ------------------------------------------------
題目 3：primitive vs reference
------------------------------------------------ */

let x = 5
let y = x
y = 10

console.log(x)
// 問題：輸出結果是什麼？
// 答案：5， Call by value

/* ------------------------------------------------
題目 4：reference type 指向
------------------------------------------------ */

let foo = { count: 1 }
let bar = foo

bar.count = 2

console.log(foo.count)
// 問題：輸出結果是什麼？為什麼會是這個結果？
// 答案：輸出結果：2  ， Call by reference

/* ------------------------------------------------
題目 5：function 回傳值
------------------------------------------------ */

function add(a, b) {
  a + b
}

const result = add(2, 3)
console.log(result)
// 問題：輸出結果是什麼？為什麼？
// 答案：這題輸出結果為：undefined，因為在function函數沒有 return

/* ------------------------------------------------
題目 6：return 之後會發生什麼事
------------------------------------------------ */

function testReturn() {
  return 10
  console.log('hello')
}

console.log(testReturn())
// 問題：console.log('hello') 會不會執行？
// 答案：console.log('hello') 這段不會做執行，因為前面已經做 return

/* ------------------------------------------------
題目 7：if 判斷與 truthy / falsy
------------------------------------------------ */

if ('') {
  console.log('A')
} else {
  console.log('B')
}
// 問題：輸出 A 還是 B？為什麼？
// 答案：輸出答案：B ，因為空字串本身就是falsy

/* ------------------------------------------------
題目 8：== 與 ===
------------------------------------------------ */

console.log(0 == false)
console.log(0 === false)
// 問題：這兩行各自輸出什麼？差別在哪？
// 答案：上面是true，下面會輸出false，因為上面的'=='會做轉型別，下面的'==='會嚴格比較。

/* ------------------------------------------------
題目 9：for 迴圈基本理解
------------------------------------------------ */

let sum = 0

for (let i = 1; i <= 3; i++) {
  sum += i
}

console.log(sum)
// 問題：輸出結果是什麼？
// 答案：6

/* ------------------------------------------------
題目 10：break 與 continue
------------------------------------------------ */

for (let i = 1; i <= 5; i++) {
  if (i === 3) continue
  console.log(i)
}
// 問題：哪些數字會被印出來？
// 答案：1,2,4,5

/* ------------------------------------------------
題目 11：function scope（var vs let）
------------------------------------------------ */

function scopeTest() {
  if (true) {
    var a = 1
    let b = 2
  }

  console.log(a)
  console.log(b)
}

scopeTest()
// 問題：哪一行會報錯？為什麼？
// 答案：這題 let b = 2 會報錯，因為 let 是區塊作用域，而 var 是函式作用域


/* ------------------------------------------------
題目 12：陣列基本操作
------------------------------------------------ */

const arr = [1, 2, 3]
arr.push(4)

console.log(arr.length)
// 問題：輸出結果是什麼？
// 答案：4 ， 因為 arr.length 的 length 是來確認陣列裡目前有幾個元素
// 那 push(4) 會將4從最後一個推進去，所以輸出是4

/* ------------------------------------------------
題目 13：物件存取
------------------------------------------------ */

const user = {
  name: 'Jeremy',
  age: 18
}

const key = 'name'
console.log(user[key])
// 問題：為什麼不能寫 user.key？
// 答案：輸出答案為：Jeremy，因為 const key = 'name' 這邊是取 'name' 的值，而user[key]是用「變數的值」當作屬性名稱來取物件資料
// 而 user.key 是直接去找屬性名稱叫做 key 這個值，但是物件裡面沒有 key 這個屬性，所以會得到undefined。

/* ------------------------------------------------
題目 14：this（不含 bind / call / apply）
------------------------------------------------ */

const person = {
  name: 'Jeremy',
  sayName() {
    console.log(this.name)
  }
}

person.sayName()
// 問題：this 指的是誰？
// 答案：輸出結果是：Jeremy，這邊this是指person這個東西，因為使用this.name去取name: 'Jeremy'。

/* ------------------------------------------------
題目 15：純同步思考題（最重要）
------------------------------------------------ */

// 請用一句話說明：
// 「為什麼 JavaScript 需要有良好的程式碼順序規劃？」

// 答案：因為在javascript的程式碼運行是，由上而下的方式在運作，不能跳行去運作(除非是很重要必須先執行)
// 而要有良好的順序規劃會讓在閱讀、檢查等方面上，會更好的快速了解程式碼的哪邊出錯及哪邊需要先修改的地方。
